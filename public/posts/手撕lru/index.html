<!DOCTYPE html>
<html lang="en">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  
    <title>手撕LRU（Go语言版本） :: Orion&#39;s Blog</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="LRU的Go实现版本（力扣型核心代码）" />
<meta name="keywords" content="LRU, Go" />

  <meta name="robots" content="noodp" />

<link rel="canonical" href="//localhost:1313/posts/%E6%89%8B%E6%92%95lru/" />





  
  <link rel="stylesheet" href="//localhost:1313/css/buttons.min.86f6b4c106b6c6eb690ae5203d36b442c1f66f718ff4e8164fa86cf6c61ad641.css">

  
  <link rel="stylesheet" href="//localhost:1313/css/code.min.d529ea4b2fb8d34328d7d31afc5466d5f7bc2f0bc9abdd98b69385335d7baee4.css">

  
  <link rel="stylesheet" href="//localhost:1313/css/fonts.min.5bb7ed13e1d00d8ff39ea84af26737007eb5051b157b86fc24487c94f3dc8bbe.css">

  
  <link rel="stylesheet" href="//localhost:1313/css/footer.min.eb8dfc2c6a7eafa36cd3ba92d63e69e849e2200e0002a228d137f236b09ecd75.css">

  
  <link rel="stylesheet" href="//localhost:1313/css/gist.min.a751e8b0abe1ba8bc53ced52a38b19d8950fe78ca29454ea8c2595cf26aad5c0.css">

  
  <link rel="stylesheet" href="//localhost:1313/css/header.min.75c7eb0e2872d95ff48109c6647d0223a38db52e2561dd87966eb5fc7c6bdac6.css">

  
  <link rel="stylesheet" href="//localhost:1313/css/main.min.775ac2af004d44c22a6d000fbd1d9af529642f5cef27399d0280d180af2c2e9b.css">

  
  <link rel="stylesheet" href="//localhost:1313/css/menu.min.310d32205bdedd6f43144e3c3273c9deecd238eba5f9108db5ea96ca0cfbe377.css">

  
  <link rel="stylesheet" href="//localhost:1313/css/pagination.min.bbb986dbce00a5ce5aca0504b7925fc1c581992a4bf57f163e5d69cc1db7d836.css">

  
  <link rel="stylesheet" href="//localhost:1313/css/post.min.ad50c7f4d00e7975918f37fc74c6029e1959a40d66fb5b2c6564a8715e985573.css">

  
  <link rel="stylesheet" href="//localhost:1313/css/syntax.min.e9ab635cf918bc84b901eb65c0b2caa74c9544245e3647c1af5c129896ef276e.css">

  
  <link rel="stylesheet" href="//localhost:1313/css/terminal.min.e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855.css">

  
  <link rel="stylesheet" href="//localhost:1313/css/terms.min.b81791663c3790e738e571cdbf802312390d30e4b1d8dc9d814a5b5454d0ac11.css">


<link rel="stylesheet" href="//localhost:1313/terminal.css">




<link rel="shortcut icon" href="//localhost:1313/favicon.png">
<link rel="apple-touch-icon" href="//localhost:1313/apple-touch-icon.png">


<meta name="twitter:card" content="summary" />

  
    <meta name="twitter:site" content="" />
  
    <meta name="twitter:creator" content="Orion Young" />



<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="手撕LRU（Go语言版本）">
<meta property="og:description" content="LRU的Go实现版本（力扣型核心代码）" />
<meta property="og:url" content="//localhost:1313/posts/%E6%89%8B%E6%92%95lru/" />
<meta property="og:site_name" content="Orion&#39;s Blog" />

  
  
  <meta property="og:image" content="//localhost:1313/">

<meta property="og:image:width" content="1200">
<meta property="og:image:height" content="627">


  <meta property="article:published_time" content="2025-08-27 00:00:00 &#43;0000 UTC" />












</head>
<body>


<div class="container center">

  <header class="header">
  <div class="header__inner">
    <div class="header__logo">
      <a href="/">
  <div class="logo">
    Welcome to Orion&#39;s Blog
  </div>
</a>

    </div>
    
      <ul class="menu menu--mobile">
  <li class="menu__trigger">Menu&nbsp;▾</li>
  <li>
    <ul class="menu__dropdown">
      
        
          <li><a href="/">主页</a></li>
        
      
        
          <li><a href="/about">关于</a></li>
        
      
        
          <li><a href="/showcase">展示</a></li>
        
      
      
    </ul>
  </li>
</ul>

    
    
  </div>
  
    <nav class="navigation-menu">
  <ul class="navigation-menu__inner menu--desktop">
    
      
        
          <li><a href="/" >主页</a></li>
        
      
        
          <li><a href="/about" >关于</a></li>
        
      
        
          <li><a href="/showcase" >展示</a></li>
        
      
      
    
  </ul>
</nav>

  
</header>


  <div class="content">
    
<article class="post">
  <h1 class="post-title">
    <a href="//localhost:1313/posts/%E6%89%8B%E6%92%95lru/">手撕LRU（Go语言版本）</a>
  </h1>
  <div class="post-meta"><time class="post-date">2025-08-27</time><span class="post-author">Orion Young</span></div>

  
    <span class="post-tags">
      
      #<a href="//localhost:1313/tags/%E7%AE%97%E6%B3%95/">算法</a>&nbsp;
      
      #<a href="//localhost:1313/tags/"></a>&nbsp;
      
    </span>
  
  


  
    <div class="table-of-contents">
      <h2>
        Table of Contents
      </h2>
      <nav id="TableOfContents">
  <ul>
    <li><a href="#1使用containerlist实现">1.使用container/list实现</a>
      <ul>
        <li><a href="#标准库list详解">标准库list详解</a></li>
        <li><a href="#初始化链表">初始化链表</a></li>
      </ul>
    </li>
    <li><a href="#基本操作">基本操作</a>
      <ul>
        <li><a href="#添加元素">添加元素</a></li>
        <li><a href="#删除元素">删除元素</a></li>
        <li><a href="#遍历链表">遍历链表</a></li>
      </ul>
    </li>
    <li><a href="#链表的特性">链表的特性</a></li>
    <li><a href="#常见应用场景">常见应用场景</a>
      <ul>
        <li><a href="#代码实现">代码实现</a></li>
      </ul>
    </li>
  </ul>
</nav>
    </div>
  

  <div class="post-content"><div>
        <h2 id="1使用containerlist实现">1.使用container/list实现<a href="#1使用containerlist实现" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<blockquote>
<p>首先，我们要了解标准库中的双向链表list</p></blockquote>
<h3 id="标准库list详解">标准库list详解<a href="#标准库list详解" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<blockquote>
<p>list.go源文件https://cs.opensource.google/go/go/+/refs/tags/go1.24.2:src/container/list/list.go</p></blockquote>
<p>在 Go 语言的 <code>container/list</code> 包中，<code>Element</code> 结构体代表双向链表中的一个节点。该结构体的定义以及相关字段的用途如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Element</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 指向前一个和后一个元素的指针</span>
</span></span><span class="line"><span class="cl">    <span class="nx">next</span><span class="p">,</span> <span class="nx">prev</span> <span class="o">*</span><span class="nx">Element</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 指向该元素所在链表的指针</span>
</span></span><span class="line"><span class="cl">    <span class="nx">list</span> <span class="o">*</span><span class="nx">List</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 存储在该元素中的值</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Value</span> <span class="kd">interface</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>下面详细解释 <code>Element</code> 结构体的各个字段：</p>
<ol>
<li><code>next</code> 和 <code>prev</code></li>
</ol>
<ul>
<li>类型为 <code>*Element</code>，也就是指向 <code>Element</code> 结构体的指针。</li>
<li><code>next</code> 指向链表中的下一个元素，<code>prev</code> 指向链表中的前一个元素。借助这两个指针，链表能够实现双向遍历。</li>
</ul>
<ol start="2">
<li><code>list</code></li>
</ol>
<ul>
<li>类型为 <code>*List</code>，即指向 <code>List</code> 结构体的指针。</li>
<li>此指针指向该元素所在的链表，其作用在于确保元素和链表之间的关联，并且在对元素进行操作时，能够保证操作的正确性。</li>
</ul>
<ol start="3">
<li><code>Value</code></li>
</ol>
<ul>
<li>类型为 <code>interface{}</code>，这意味着它能够存储任意类型的值。</li>
<li>该字段用于存放用户在链表节点中存储的数据。</li>
</ul>
<p>Element定义了<code>Next()</code>和<code>Prev()</code>方法，定义如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Next returns the next list element or nil.</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">Element</span><span class="p">)</span> <span class="nf">Next</span><span class="p">()</span> <span class="o">*</span><span class="nx">Element</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">p</span> <span class="o">:=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">next</span><span class="p">;</span> <span class="nx">e</span><span class="p">.</span><span class="nx">list</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">p</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="nx">e</span><span class="p">.</span><span class="nx">list</span><span class="p">.</span><span class="nx">root</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nx">p</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Prev returns the previous list element or nil.</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">Element</span><span class="p">)</span> <span class="nf">Prev</span><span class="p">()</span> <span class="o">*</span><span class="nx">Element</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">p</span> <span class="o">:=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">prev</span><span class="p">;</span> <span class="nx">e</span><span class="p">.</span><span class="nx">list</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">p</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="nx">e</span><span class="p">.</span><span class="nx">list</span><span class="p">.</span><span class="nx">root</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nx">p</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>总的来说，这两个方法的执行逻辑是：</p>
<ul>
<li>如果该元素在某一个链表上，且其前一个（后一个）元素不是链表的根元素，则返回其前一个（后一个）元素</li>
<li>其它情况下，即如果该元素不属于任何链表，或者其前一个（后一个）元素为链表的根元素，则返回<code>nil</code>（即：链表的根元素只起到一个占位作用，而并不会存储数据值）</li>
</ul>
<h3 id="初始化链表">初始化链表<a href="#初始化链表" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>我们可以通过调用<code>list.New()</code>函数或者直接声明一个<code>list.List</code>类型的变量来初始化一个链表：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// 方法一：使用list.New()函数</span>
</span></span><span class="line"><span class="cl"><span class="nx">l</span> <span class="o">:=</span> <span class="nx">list</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 方法二：直接声明一个list.List变量</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">l</span> <span class="nx">list</span><span class="p">.</span><span class="nx">List</span>
</span></span></code></pre></div><h2 id="基本操作">基本操作<a href="#基本操作" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<h3 id="添加元素">添加元素<a href="#添加元素" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p><code>container/list</code>包提供了多种方法来向链表中添加元素：</p>
<ul>
<li>• <code>PushFront(v interface{}) *Element</code>：在链表的头部插入一个元素，返回该元素的指针。</li>
<li>• <code>PushBack(v interface{}) *Element</code>：在链表的尾部插入一个元素，返回该元素的指针。</li>
<li>• <code>InsertBefore(v interface{}, mark *Element) *Element</code>：在指定元素之前插入一个新元素。</li>
<li>• <code>InsertAfter(v interface{}, mark *Element) *Element</code>：在指定元素之后插入一个新元素。</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">l</span> <span class="o">:=</span> <span class="nx">list</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="nx">l</span><span class="p">.</span><span class="nf">PushBack</span><span class="p">(</span><span class="s">&#34;Go&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">l</span><span class="p">.</span><span class="nf">PushFront</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">e</span> <span class="o">:=</span> <span class="nx">l</span><span class="p">.</span><span class="nf">PushBack</span><span class="p">(</span><span class="mf">3.14</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">l</span><span class="p">.</span><span class="nf">InsertBefore</span><span class="p">(</span><span class="s">&#34;before&#34;</span><span class="p">,</span> <span class="nx">e</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">l</span><span class="p">.</span><span class="nf">InsertAfter</span><span class="p">(</span><span class="s">&#34;after&#34;</span><span class="p">,</span> <span class="nx">e</span><span class="p">)</span>
</span></span></code></pre></div><h3 id="删除元素">删除元素<a href="#删除元素" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>可以使用<code>Remove</code>方法删除链表中的元素，<code>Remove</code>方法接受一个指向链表元素的指针，删除该元素并返回其值：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">l</span> <span class="o">:=</span> <span class="nx">list</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="nx">e</span> <span class="o">:=</span> <span class="nx">l</span><span class="p">.</span><span class="nf">PushBack</span><span class="p">(</span><span class="s">&#34;to be removed&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">l</span><span class="p">.</span><span class="nf">Remove</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span>
</span></span></code></pre></div><h3 id="遍历链表">遍历链表<a href="#遍历链表" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>可以使用<code>Front()</code>和<code>Back()</code>方法获取链表的第一个和最后一个元素，然后通过元素的<code>Next()</code>和<code>Prev()</code>方法进行遍历：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// 从前向后遍历</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="nx">e</span> <span class="o">:=</span> <span class="nx">l</span><span class="p">.</span><span class="nf">Front</span><span class="p">();</span> <span class="nx">e</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">;</span> <span class="nx">e</span> <span class="p">=</span> <span class="nx">e</span><span class="p">.</span><span class="nf">Next</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">Value</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 从后向前遍历</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="nx">e</span> <span class="o">:=</span> <span class="nx">l</span><span class="p">.</span><span class="nf">Back</span><span class="p">();</span> <span class="nx">e</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">;</span> <span class="nx">e</span> <span class="p">=</span> <span class="nx">e</span><span class="p">.</span><span class="nf">Prev</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">Value</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="链表的特性">链表的特性<a href="#链表的特性" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<ul>
<li>• <strong>双向链表</strong>：每个节点有两个指针，分别指向前一个节点和后一个节点。</li>
<li>• <strong>O(1)时间复杂度的插入和删除</strong>：链表的插入和删除操作都只需要调整指针，因此效率很高。</li>
<li>• <strong>遍历效率较低</strong>：由于链表节点不连续存储，无法利用CPU缓存，遍历效率相对于数组较低。</li>
</ul>
<h2 id="常见应用场景">常见应用场景<a href="#常见应用场景" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<ol>
<li>
<ol>
<li><strong>需要频繁插入和删除操作的场景</strong>：由于链表插入和删除操作的时间复杂度为O(1)，在需要频繁进行这些操作时，链表表现优异。</li>
</ol>
</li>
<li>
<ol start="2">
<li><strong>实现LRU缓存</strong>：链表和哈希表的结合可以高效实现LRU（最近最少使用）缓存。</li>
</ol>
</li>
<li>
<ol start="3">
<li><strong>队列和双端队列</strong>：链表可以方便地实现FIFO队列和双端队列。</li>
</ol>
</li>
</ol>
<h3 id="代码实现">代码实现<a href="#代码实现" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">import</span> <span class="s">&#34;container/list&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">LRUCache</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Cap</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Keys</span> <span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="o">*</span><span class="nx">list</span><span class="p">.</span><span class="nx">Element</span> <span class="c1">// element.Value放的是pair</span>
</span></span><span class="line"><span class="cl">    <span class="nx">List</span> <span class="o">*</span><span class="nx">list</span><span class="p">.</span><span class="nx">List</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Pair</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">k</span><span class="p">,</span> <span class="nx">v</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">Constructor</span><span class="p">(</span><span class="nx">capacity</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">LRUCache</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">LRUCache</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">Cap</span><span class="p">:</span> <span class="nx">capacity</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nx">Keys</span><span class="p">:</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="o">*</span><span class="nx">list</span><span class="p">.</span><span class="nx">Element</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">        <span class="nx">List</span><span class="p">:</span> <span class="nx">list</span><span class="p">.</span><span class="nf">New</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">this</span> <span class="o">*</span><span class="nx">LRUCache</span><span class="p">)</span> <span class="nf">Get</span><span class="p">(</span><span class="nx">key</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 命中要把key放链表头</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">elmt</span><span class="p">,</span> <span class="nx">exists</span> <span class="o">:=</span> <span class="nx">this</span><span class="p">.</span><span class="nx">Keys</span><span class="p">[</span><span class="nx">key</span><span class="p">];</span> <span class="nx">exists</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">this</span><span class="p">.</span><span class="nx">List</span><span class="p">.</span><span class="nf">MoveToFront</span><span class="p">(</span><span class="nx">elmt</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nx">elmt</span><span class="p">.</span><span class="nx">Value</span><span class="p">.(</span><span class="nx">Pair</span><span class="p">).</span><span class="nx">v</span> <span class="c1">// elmt是结点，结点里面有数据域Value，是一个pair</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">this</span> <span class="o">*</span><span class="nx">LRUCache</span><span class="p">)</span> <span class="nf">Put</span><span class="p">(</span><span class="nx">key</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">value</span> <span class="kt">int</span><span class="p">)</span>  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 链表头插入</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">elmt</span><span class="p">,</span> <span class="nx">exists</span> <span class="o">:=</span> <span class="nx">this</span><span class="p">.</span><span class="nx">Keys</span><span class="p">[</span><span class="nx">key</span><span class="p">];</span> <span class="nx">exists</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 存在，更新值</span>
</span></span><span class="line"><span class="cl">        <span class="nx">elmt</span><span class="p">.</span><span class="nx">Value</span> <span class="p">=</span> <span class="nx">Pair</span><span class="p">{</span><span class="nx">k</span><span class="p">:</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">v</span><span class="p">:</span> <span class="nx">value</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nx">this</span><span class="p">.</span><span class="nx">List</span><span class="p">.</span><span class="nf">MoveToFront</span><span class="p">(</span><span class="nx">elmt</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 不存在</span>
</span></span><span class="line"><span class="cl">        <span class="nx">newElmt</span> <span class="o">:=</span> <span class="nx">this</span><span class="p">.</span><span class="nx">List</span><span class="p">.</span><span class="nf">PushFront</span><span class="p">(</span><span class="nx">Pair</span><span class="p">{</span><span class="nx">k</span><span class="p">:</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">v</span><span class="p">:</span> <span class="nx">value</span><span class="p">})</span>
</span></span><span class="line"><span class="cl">        <span class="nx">this</span><span class="p">.</span><span class="nx">Keys</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="p">=</span> <span class="nx">newElmt</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">this</span><span class="p">.</span><span class="nx">List</span><span class="p">.</span><span class="nf">Len</span><span class="p">()</span> <span class="p">&gt;</span> <span class="nx">this</span><span class="p">.</span><span class="nx">Cap</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">lastElmt</span> <span class="o">:=</span> <span class="nx">this</span><span class="p">.</span><span class="nx">List</span><span class="p">.</span><span class="nf">Back</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">            <span class="nx">this</span><span class="p">.</span><span class="nx">List</span><span class="p">.</span><span class="nf">Remove</span><span class="p">(</span><span class="nx">lastElmt</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 使用 lastElmt 来删除 Keys 中的键</span>
</span></span><span class="line"><span class="cl">            <span class="nb">delete</span><span class="p">(</span><span class="nx">this</span><span class="p">.</span><span class="nx">Keys</span><span class="p">,</span> <span class="nx">lastElmt</span><span class="p">.</span><span class="nx">Value</span><span class="p">.(</span><span class="nx">Pair</span><span class="p">).</span><span class="nx">k</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * Your LRUCache object will be instantiated and called as such:
</span></span></span><span class="line"><span class="cl"><span class="cm"> * obj := Constructor(capacity);
</span></span></span><span class="line"><span class="cl"><span class="cm"> * param_1 := obj.Get(key);
</span></span></span><span class="line"><span class="cl"><span class="cm"> * obj.Put(key,value);
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span></code></pre></div><p><img src="http://img.orionyoung.com/pic/%E6%89%8B%E6%92%95LRU.png" alt="手撕LRU"></p>
<p>想要O1存取，一定要借助map，先查map，map{key，指向链表结点的指针}，链表又包含四个元素{1.prev，2.next，3.pair{key，val}，4.this.List}</p>
<p>结点为什么还要存一个键值对pair，存个val不就行了吗？</p>
<ul>
<li>pair是为了删除元素服务的。</li>
<li>如果没有pair，超过容量cap时，我们要删去队列尾部进程，我们要删两个地方，一个是map，一个是链表尾结点，流程是删去结点，再删map[key]，链表结点里面只有val，没有key，删去后我们我们要遍历map找哪个key对应element的val，这是On复杂度</li>
<li>如果有pair，删去结点时，我们能得到pair{key, val}，这样拿着key进行O1复杂度的map删除</li>
<li>不能先删map！若先从 <code>map</code> 里删除键值对，再去删除链表节点，在删除链表节点的过程中要是出现异常（例如链表操作逻辑出错、内存错误等），那么 <code>map</code> 里对应的键值对已被删除，可链表节点却还存在，这就会造成数据不一致。在 LRU 缓存里，链表节点和 <code>map</code> 中的键值对是相互关联的。若先删除 <code>map</code> 中的键值对，后续再删除链表节点时，就难以依据 <code>map</code> 快速定位到要删除的链表节点，因为 <code>map</code> 里已经没有对应的映射信息了。</li>
</ul>

      </div></div>

  
    
<div class="pagination">
  <div class="pagination__title">
    <span class="pagination__title-h">阅读其他文章</span>
    <hr />
  </div>
  <div class="pagination__buttons">
    
    
    
      <a href="//localhost:1313/posts/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/" class="button inline next">
         [<span class="button__text">测试</span>] &gt;
      </a>
    
  </div>
</div>


  

  
    

  
</article>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright">
        <span>© 2025 Powered by <a href="https://gohugo.io">Hugo</a></span>
    
      <span>:: <a href="https://github.com/panr/hugo-theme-terminal" target="_blank">Theme</a> made by <a href="https://github.com/panr" target="_blank">panr</a></span>
      </div>
  </div>
</footer>






<script type="text/javascript" src="/bundle.min.js"></script>





  
</div>

</body>
</html>
